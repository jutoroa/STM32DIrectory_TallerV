/*
 * mainTarea4.c
 *
 *  Created on: 4/05/2022
 *  Author: Juan Pablo
 *
 * Esta tarea pretende implementar un sumador de dos dígitos, en donde cada unidad se aumenta debido a una interrupción
 * del EXTI, la cuál podrá estar dada por un botón, o una fotocompuerta. Los resultados de la suma se pondrán observar
 * en un Display 7 segmentos.
 */


// *************** // INCLUDES // *************** //
#include <stm32f4xx.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

#include <stdint.h>
#include <stdbool.h>
#include "GPIOxDriver.h"
#include "USARTxDriver.h"
#include "TIMxDriver.h"
#include "AdcDriver.h"
#include "EXTIxDriver.h"


// *************** // VARIABLES PROYECTO // *************** //

GPIO_Handler_t 	handlerStateLED 		= {0};	// StateLED
GPIO_Handler_t 	handlerPinTX 			= {0};	// handlerPinTX
GPIO_Handler_t 	handlerPinRX 			= {0};	// handlerPinRX
TIMER_Handler_t handlerTimer2 			= {0};	// Timer2
USART_Handler_t handlerCommTerminal		= {0};	// Usart para la terminal

/* Configuración para el I2C */
GPIO_Handler_t handlerI2CSDA =	{0};
GPIO_Handler_t handlerI2CSCL =	{0};
I2C_Handler_t  handlerAccelerometer = {0};
uint8_t i2cBuffer = 0;


// Variables auxiliar.

uint8_t rxData = 0;
char bufferData[64] = "esto es una pequeña prueba";

uint32_t systemTicks = 0;
uint32_t systemTicksStart = 0;
uint32_t systemTicksEnd		= 0;


#define ACCEL_XOUT_H	59
#define ACCEL_XOUT_L	60
#define ACCEL_YOUT_H	61
#define ACCEL_YOUT_L	62

#define PWR_MGMT_1		107
#define WHO_AM_I		175

// *************** // Headers // *************** //

void initSystem(void);

// *************** // MAIN // *************** //
int main(void)
{
	// Inicializamos el sistema
	initSystem();


	/* Main Loop */
	while(1){

		// Hacemos un "eco" con el valor que nos llega por el serial
		if(rxData != '\0'){
			writeChar(&handlerCommTerminal, rxData);

			if(rxData == 'd'){
				i2cBuffer = I2C_readByte(&handlerAccelerometer, WHO_AM_I);
				sprintf(bufferData, "dataRead = 0x%2x \n", (unsigned int) i2cBuffer);
				writeMsg(&handlerCommTerminal, bufferData);
				rxData = '\0';
			}
			else if(rxData == 'p'){
				i2cBuffer = I2C_readByte(&handlerAccelerometer, PWR_MGMT_1);
				sprintf(bufferData, "dataRead = 0x%2x \n", (unsigned int) i2cBuffer);
				writeMsg(&handlerCommTerminal, bufferData);
				rxData = '\0';
			}
			else if(rxData == 'r'){
				I2C_writeByte(&handlerAccelerometer, PWR_MGMT_1, 0x00);
				rxData = '\0';
			}
			else if(rxData == 'x'){
				uint8_t AccelX_low = I2C_readByte(&handlerAccelerometer, ACCEL_XOUT_L);
				uint8_t AccelX_high = I2C_readByte(&handlerAccelerometer, ACCEL_XOUT_H);


				i2cBuffer = I2C_readByte(&handlerAccelerometer, PWR_MGMT_1);
				sprintf(bufferData, "dataRead = 0x%2x \n", (unsigned int) i2cBuffer);
				writeMsg(&handlerCommTerminal, bufferData);
				rxData = '\0';
			}
	}
}
//***********// *********** // Definición de Funciones // *********** //***********//

//***********// InitSystem //***********//

// Función que define la configuración de todos los pines y periféricos

void initSystem(void){

	// Configuración el State LED
	handlerStateLED.pGPIOx								= GPIOA;
	handlerStateLED.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerStateLED.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerStateLED.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerStateLED.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerStateLED.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerStateLED);

	// Configuración el Switch LED
	handlerSwitchLED.pGPIOx								= GPIOA;
	handlerSwitchLED.GPIO_PinConfig.GPIO_PinNumber		= PIN_6;
	handlerSwitchLED.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_OUT;
	handlerSwitchLED.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerSwitchLED.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSwitchLED.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSwitchLED);

	// Prendemos el Switch LED
	GPIO_WritePin(&handlerSwitchLED, SET);

	// Configuración del Transistor Unidades
	handlerTransistorUnidades.pGPIOx								= GPIOB;
	handlerTransistorUnidades.GPIO_PinConfig.GPIO_PinNumber			= PIN_5;
	handlerTransistorUnidades.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerTransistorUnidades.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerTransistorUnidades.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerTransistorUnidades.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerTransistorUnidades);

	// Configuración del Transistor Decenas
	handlerTransistorDecenas.pGPIOx									= GPIOC;
	handlerTransistorDecenas.GPIO_PinConfig.GPIO_PinNumber			= PIN_5;
	handlerTransistorDecenas.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerTransistorDecenas.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerTransistorDecenas.GPIO_PinConfig.GPIO_PinPuPdControl		= GPIO_PUPDR_NOTHING;
	handlerTransistorDecenas.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerTransistorDecenas);

	// Desincronizamos los dos display
	handlerTransistorDecenas.pGPIOx -> ODR ^= GPIO_ODR_OD5;

	// Configuración del timer2
	handlerTimer2.ptrTIMx								= TIM2;
	handlerTimer2.timerConfig.Timer_mode				= TIMER_MODE_UP;
	handlerTimer2.timerConfig.Timer_speed				= TIMER_INCR_SPEED_1ms;
	handlerTimer2.timerConfig.Timer_period				= 250;

	Timer_Config(&handlerTimer2);

	// Configuración del timer 4

	handlerTimer4.ptrTIMx								= TIM4;
	handlerTimer4.timerConfig.Timer_mode				= TIMER_MODE_UP;
	handlerTimer4.timerConfig.Timer_speed				= TIMER_INCR_SPEED_1ms;
	handlerTimer4.timerConfig.Timer_period				= 10;

	Timer_Config(&handlerTimer4);

	// Configuración del EXTI0

	handlerEXTI0.port 		= GPIOA;
	handlerEXTI0.pin		= PIN_0;
	handlerEXTI0.trigger	= TRIGGER_FALLING;
	handlerEXTI0.PinControl	= GPIO_PUPDR_PULLUP;

	EXTI_Config(&handlerEXTI0);

	// Configuración del EXTI3

	handlerEXTI3.port 		= GPIOC;
	handlerEXTI3.pin		= PIN_3;
	handlerEXTI3.trigger	= TRIGGER_FALLING;
	handlerEXTI3.PinControl	= GPIO_PUPDR_PULLUP;

	EXTI_Config(&handlerEXTI3);

	// Configuración Segmento A

	handlerSevenSegmentsA.pGPIOx								= GPIOB;
	handlerSevenSegmentsA.GPIO_PinConfig.GPIO_PinNumber			= PIN_4;
	handlerSevenSegmentsA.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsA.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsA.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsA.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsA);

	// Configuración Segmento B

	handlerSevenSegmentsB.pGPIOx								= GPIOB;
	handlerSevenSegmentsB.GPIO_PinConfig.GPIO_PinNumber			= PIN_3;
	handlerSevenSegmentsB.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsB.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsB.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsB.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsB);

	// Configuración Segmento C

	handlerSevenSegmentsC.pGPIOx								= GPIOC;
	handlerSevenSegmentsC.GPIO_PinConfig.GPIO_PinNumber			= PIN_2;
	handlerSevenSegmentsC.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsC.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsC.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsC.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsC);

	// Configuración Segmento D

	handlerSevenSegmentsD.pGPIOx								= GPIOC;
	handlerSevenSegmentsD.GPIO_PinConfig.GPIO_PinNumber			= PIN_13;
	handlerSevenSegmentsD.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsD.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsD.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsD.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsD);

	// Configuración Segmento E

	handlerSevenSegmentsE.pGPIOx								= GPIOC;
	handlerSevenSegmentsE.GPIO_PinConfig.GPIO_PinNumber			= PIN_1;
	handlerSevenSegmentsE.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsE.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsE.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsE.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsE);

	// Configuración Segmento F

	handlerSevenSegmentsF.pGPIOx								= GPIOB;
	handlerSevenSegmentsF.GPIO_PinConfig.GPIO_PinNumber			= PIN_2;
	handlerSevenSegmentsF.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsF.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsF.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsF.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsF);

	// Configuración Segmento G

	handlerSevenSegmentsG.pGPIOx								= GPIOB;
	handlerSevenSegmentsG.GPIO_PinConfig.GPIO_PinNumber			= PIN_1;
	handlerSevenSegmentsG.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerSevenSegmentsG.GPIO_PinConfig.GPIO_PinOPType			= GPIO_OTYPE_PUSHPULL;
	handlerSevenSegmentsG.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerSevenSegmentsG.GPIO_PinConfig.GPIO_PinSpeed			= GPIO_OSPEED_MEDIUM;

	//Cargamos la configuración
	GPIO_Config(&handlerSevenSegmentsG);

	//Cargamos la configuración inicial

	GPIO_WritePin(&handlerSevenSegmentsA, SET);
	GPIO_WritePin(&handlerSevenSegmentsB, SET);
	GPIO_WritePin(&handlerSevenSegmentsC, SET);
	GPIO_WritePin(&handlerSevenSegmentsD, SET);
	GPIO_WritePin(&handlerSevenSegmentsE, SET);
	GPIO_WritePin(&handlerSevenSegmentsF, SET);
	GPIO_WritePin(&handlerSevenSegmentsG, SET);
	GPIO_WritePin(&handlerSevenSegmentsP, SET);
}

//***********// setNumber //***********//

// Función que tiene la configuración para cada uno de los números del 0 al 9.

void setNumber(uint32_t number){

	switch(number){
	// Número 0
	case(0):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, RESET);
		GPIO_WritePin(&handlerSevenSegmentsF, RESET);
		GPIO_WritePin(&handlerSevenSegmentsG, SET);
		break;
	}

	// Número 1
	case(1):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, SET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, SET);
		GPIO_WritePin(&handlerSevenSegmentsE, SET);
		GPIO_WritePin(&handlerSevenSegmentsF, SET);
		GPIO_WritePin(&handlerSevenSegmentsG, SET);
		break;
	}

	// Número 2
	case(2):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, SET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsF, SET);
		break;
	}

	// Número 3
	case(3):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, SET);
		GPIO_WritePin(&handlerSevenSegmentsF, SET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		break;
	}

	// Número 4
	case(4):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, SET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, SET);
		GPIO_WritePin(&handlerSevenSegmentsE, SET);
		GPIO_WritePin(&handlerSevenSegmentsF, RESET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		break;
	}

	// Número 5
	case(5):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, SET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, SET);
		GPIO_WritePin(&handlerSevenSegmentsF, RESET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		break;
	}

	// Número 6
	case(6):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, SET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, RESET);
		GPIO_WritePin(&handlerSevenSegmentsF, RESET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		break;
	}

	// Número 7
	case(7):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, SET);
		GPIO_WritePin(&handlerSevenSegmentsE, SET);
		GPIO_WritePin(&handlerSevenSegmentsF, SET);
		GPIO_WritePin(&handlerSevenSegmentsG, SET);
		break;
	}

	// Número 8
	case(8):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, RESET);
		GPIO_WritePin(&handlerSevenSegmentsF, RESET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		break;
	}

	// Número 9
	case(9):
	{
		GPIO_WritePin(&handlerSevenSegmentsA, RESET);
		GPIO_WritePin(&handlerSevenSegmentsB, RESET);
		GPIO_WritePin(&handlerSevenSegmentsC, RESET);
		GPIO_WritePin(&handlerSevenSegmentsD, RESET);
		GPIO_WritePin(&handlerSevenSegmentsE, SET);
		GPIO_WritePin(&handlerSevenSegmentsF, RESET);
		GPIO_WritePin(&handlerSevenSegmentsG, RESET);
		break;
	}
	}
}

//***********// CallBacks //***********//

// Timer encargado del StateLED
void Timer2_Callback(void){
	handlerStateLED.pGPIOx -> ODR ^= GPIO_ODR_OD5;		// Encendido y apagado StateLED
}

// Timer encargado de genera la frecuencia de oscilación de los dos transistores para los display
void Timer4_Callback(void){

	handlerTransistorUnidades.pGPIOx -> ODR ^= GPIO_ODR_OD5;	// Switcheamos el estado del Transistor Unidades

	handlerTransistorDecenas.pGPIOx -> ODR ^= GPIO_ODR_OD5;		// Switcheamos el estado del Transistor Decenas


	// Si el transistor Unidades está encendido, se muestra el valor de unidades
	if(((handlerTransistorUnidades.pGPIOx -> ODR) &= GPIO_ODR_OD5) !=  GPIO_ODR_OD5 ){
		setNumber(counterUnidades);
	// Si el transistor Decenas está encendido, se muestra el valor de Decenas
	}else if((handlerTransistorDecenas.pGPIOx -> ODR &= GPIO_ODR_OD5) != GPIO_ODR_OD5){
		setNumber(counterDecenas);
	}
}

// Interrupción externa para el botón.
void EXTI0_Callback(void){
	// Cambiamos el estado del Switch LED cada vez que se genera una interrupción.
	auxCounter ^= 1;
	// Variable para la comprobación del Bounce.
	buttonControl = 1;
}

// Interrupción externa para la fotocompuerta.
void EXTI3_Callback(void){
	// Cambiamos el estado del Switch LED cada vez que se genera una interrupción.
	auxCounter ^= 1;
	// Variable para la comprobación del Bounce.
	buttonControl = 1;
}
